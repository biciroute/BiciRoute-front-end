{"ast":null,"code":"function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n/**\r\n * Copyright (c) 2015-present, Nicolas Gallagher.\r\n * Copyright (c) 2015-present, Facebook, Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\n\n\nimport { Component } from 'react';\nimport { bool, func } from 'prop-types';\n/**\r\n * Renders static content efficiently by allowing React to short-circuit the\r\n * reconciliation process. This component should be used when you know that a\r\n * subtree of components will never need to be updated.\r\n *\r\n *   const someValue = ...; // We know for certain this value will never change.\r\n *   return (\r\n *     <StaticRenderer render={() => <MyComponent value={someValue} />} />\r\n *   );\r\n *\r\n * Typically, you will not need to use this component and should opt for normal\r\n * React reconciliation.\r\n */\n\nvar StaticRenderer =\n/*#__PURE__*/\nfunction (_Component) {\n  _inheritsLoose(StaticRenderer, _Component);\n\n  function StaticRenderer() {\n    return _Component.apply(this, arguments) || this;\n  }\n\n  var _proto = StaticRenderer.prototype;\n\n  _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {\n    return nextProps.shouldUpdate;\n  };\n\n  _proto.render = function render() {\n    return this.props.render();\n  };\n\n  return StaticRenderer;\n}(Component);\n\nexport { StaticRenderer as default };\nStaticRenderer.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  render: func.isRequired,\n  shouldUpdate: bool.isRequired\n} : {};","map":null,"metadata":{},"sourceType":"module"}