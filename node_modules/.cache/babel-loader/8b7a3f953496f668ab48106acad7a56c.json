{"ast":null,"code":"/** @license React v16.9.0\r\n * react-dom-unstable-native-dependencies.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    'use strict';\n\n    var ReactDOM = require('react-dom');\n\n    var _assign = require('object-assign'); // Do not require this module directly! Use normal `invariant` calls with\n    // template literal strings. The messages will be converted to ReactError during\n    // build, and in production they will be minified.\n    // Do not require this module directly! Use normal `invariant` calls with\n    // template literal strings. The messages will be converted to ReactError during\n    // build, and in production they will be minified.\n\n\n    function ReactError(error) {\n      error.name = 'Invariant Violation';\n      return error;\n    }\n    /**\r\n     * Use invariant() to assert state which your program assumes to be true.\r\n     *\r\n     * Provide sprintf-style format (only %s is supported) and arguments\r\n     * to provide information about what broke and what you were\r\n     * expecting.\r\n     *\r\n     * The invariant message will be stripped in production, but the invariant\r\n     * will remain to ensure logic does not differ in production.\r\n     */\n\n\n    {\n      // In DEV mode, we swap out invokeGuardedCallback for a special version\n      // that plays more nicely with the browser's DevTools. The idea is to preserve\n      // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n      // functions in invokeGuardedCallback, and the production version of\n      // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n      // like caught exceptions, and the DevTools won't pause unless the developer\n      // takes the extra step of enabling pause on caught exceptions. This is\n      // unintuitive, though, because even though React has caught the error, from\n      // the developer's perspective, the error is uncaught.\n      //\n      // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n      // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n      // DOM node, and call the user-provided callback from inside an event handler\n      // for that fake event. If the callback throws, the error is \"captured\" using\n      // a global event handler. But because the error happens in a different\n      // event loop context, it does not interrupt the normal program flow.\n      // Effectively, this gives us try-catch behavior without actually using\n      // try-catch. Neat!\n      // Check that the browser supports the APIs we need to implement our special\n      // DEV version of invokeGuardedCallback\n      if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n        var fakeNode = document.createElement('react');\n      }\n    }\n    /**\r\n     * Call a function while guarding against errors that happens within it.\r\n     * Returns an error if it throws, otherwise null.\r\n     *\r\n     * In production, this is implemented using a try-catch. The reason we don't\r\n     * use a try-catch directly is so that we can swap out a different\r\n     * implementation in DEV mode.\r\n     *\r\n     * @param {String} name of the guard to use for logging or debugging\r\n     * @param {Function} func The function to invoke\r\n     * @param {*} context The context to use when calling the function\r\n     * @param {...*} args Arguments for function\r\n     */\n\n    /**\r\n     * Same as invokeGuardedCallback, but instead of returning an error, it stores\r\n     * it in a global so it can be rethrown by `rethrowCaughtError` later.\r\n     * TODO: See if caughtError and rethrowError can be unified.\r\n     *\r\n     * @param {String} name of the guard to use for logging or debugging\r\n     * @param {Function} func The function to invoke\r\n     * @param {*} context The context to use when calling the function\r\n     * @param {...*} args Arguments for function\r\n     */\n\n    /**\r\n     * During execution of guarded functions we will capture the first error which\r\n     * we will rethrow to be handled by the top level error handler.\r\n     */\n\n    /**\r\n     * Similar to invariant but only logs a warning if the condition is not met.\r\n     * This can be used to log issues in development environments in critical\r\n     * paths. Removing the logging code for production environments will keep the\r\n     * same logic and follow the same code paths.\r\n     */\n\n    var warningWithoutStack = function () {};\n\n    {\n      warningWithoutStack = function (condition, format) {\n        for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n          args[_key - 2] = arguments[_key];\n        }\n\n        if (format === undefined) {\n          throw new Error('`warningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');\n        }\n\n        if (args.length > 8) {\n          // Check before the condition to catch violations early.\n          throw new Error('warningWithoutStack() currently supports at most 8 arguments.');\n        }\n\n        if (condition) {\n          return;\n        }\n\n        if (typeof console !== 'undefined') {\n          var argsWithFormat = args.map(function (item) {\n            return '' + item;\n          });\n          argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n          // breaks IE9: https://github.com/facebook/react/issues/13610\n\n          Function.prototype.apply.call(console.error, console, argsWithFormat);\n        }\n\n        try {\n          // --- Welcome to debugging React ---\n          // This error was thrown as a convenience so that you can use this stack\n          // to find the callsite that caused this warning to fire.\n          var argIndex = 0;\n          var message = 'Warning: ' + format.replace(/%s/g, function () {\n            return args[argIndex++];\n          });\n          throw new Error(message);\n        } catch (x) {}\n      };\n    }\n    var warningWithoutStack$1 = warningWithoutStack;\n    var getFiberCurrentPropsFromNode$1 = null;\n    var getInstanceFromNode$1 = null;\n    var getNodeFromInstance$1 = null;\n\n    function setComponentTree(getFiberCurrentPropsFromNodeImpl, getInstanceFromNodeImpl, getNodeFromInstanceImpl) {\n      getFiberCurrentPropsFromNode$1 = getFiberCurrentPropsFromNodeImpl;\n      getInstanceFromNode$1 = getInstanceFromNodeImpl;\n      getNodeFromInstance$1 = getNodeFromInstanceImpl;\n      {\n        !(getNodeFromInstance$1 && getInstanceFromNode$1) ? warningWithoutStack$1(false, 'EventPluginUtils.setComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;\n      }\n    }\n\n    var validateEventDispatches = void 0;\n    {\n      validateEventDispatches = function (event) {\n        var dispatchListeners = event._dispatchListeners;\n        var dispatchInstances = event._dispatchInstances;\n        var listenersIsArr = Array.isArray(dispatchListeners);\n        var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;\n        var instancesIsArr = Array.isArray(dispatchInstances);\n        var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;\n        !(instancesIsArr === listenersIsArr && instancesLen === listenersLen) ? warningWithoutStack$1(false, 'EventPluginUtils: Invalid `event`.') : void 0;\n      };\n    }\n    /**\r\n     * Dispatch the event to the listener.\r\n     * @param {SyntheticEvent} event SyntheticEvent to handle\r\n     * @param {function} listener Application-level callback\r\n     * @param {*} inst Internal component instance\r\n     */\n\n    /**\r\n     * Standard/simple iteration through an event's collected dispatches.\r\n     */\n\n    /**\r\n     * Standard/simple iteration through an event's collected dispatches, but stops\r\n     * at the first dispatch execution returning true, and returns that id.\r\n     *\r\n     * @return {?string} id of the first dispatch execution who's listener returns\r\n     * true, or null if no listener returned true.\r\n     */\n\n    function executeDispatchesInOrderStopAtTrueImpl(event) {\n      var dispatchListeners = event._dispatchListeners;\n      var dispatchInstances = event._dispatchInstances;\n      {\n        validateEventDispatches(event);\n      }\n\n      if (Array.isArray(dispatchListeners)) {\n        for (var i = 0; i < dispatchListeners.length; i++) {\n          if (event.isPropagationStopped()) {\n            break;\n          } // Listeners and Instances are two parallel arrays that are always in sync.\n\n\n          if (dispatchListeners[i](event, dispatchInstances[i])) {\n            return dispatchInstances[i];\n          }\n        }\n      } else if (dispatchListeners) {\n        if (dispatchListeners(event, dispatchInstances)) {\n          return dispatchInstances;\n        }\n      }\n\n      return null;\n    }\n    /**\r\n     * @see executeDispatchesInOrderStopAtTrueImpl\r\n     */\n\n\n    function executeDispatchesInOrderStopAtTrue(event) {\n      var ret = executeDispatchesInOrderStopAtTrueImpl(event);\n      event._dispatchInstances = null;\n      event._dispatchListeners = null;\n      return ret;\n    }\n    /**\r\n     * Execution of a \"direct\" dispatch - there must be at most one dispatch\r\n     * accumulated on the event or it is considered an error. It doesn't really make\r\n     * sense for an event with multiple dispatches (bubbled) to keep track of the\r\n     * return values at each dispatch execution, but it does tend to make sense when\r\n     * dealing with \"direct\" dispatches.\r\n     *\r\n     * @return {*} The return value of executing the single dispatch.\r\n     */\n\n\n    function executeDirectDispatch(event) {\n      {\n        validateEventDispatches(event);\n      }\n      var dispatchListener = event._dispatchListeners;\n      var dispatchInstance = event._dispatchInstances;\n\n      (function () {\n        if (!!Array.isArray(dispatchListener)) {\n          {\n            throw ReactError(Error('executeDirectDispatch(...): Invalid `event`.'));\n          }\n        }\n      })();\n\n      event.currentTarget = dispatchListener ? getNodeFromInstance$1(dispatchInstance) : null;\n      var res = dispatchListener ? dispatchListener(event) : null;\n      event.currentTarget = null;\n      event._dispatchListeners = null;\n      event._dispatchInstances = null;\n      return res;\n    }\n    /**\r\n     * @param {SyntheticEvent} event\r\n     * @return {boolean} True iff number of dispatches accumulated is greater than 0.\r\n     */\n\n\n    function hasDispatches(event) {\n      return !!event._dispatchListeners;\n    } // Before we know whether it is function or class\n    // Root of a host tree. Could be nested inside another node.\n    // A subtree. Could be an entry point to a different renderer.\n\n\n    var HostComponent = 5;\n\n    function getParent(inst) {\n      do {\n        inst = inst.return; // TODO: If this is a HostRoot we might want to bail out.\n        // That is depending on if we want nested subtrees (layers) to bubble\n        // events to their parent. We could also go through parentNode on the\n        // host node but that wouldn't work for React Native and doesn't let us\n        // do the portal feature.\n      } while (inst && inst.tag !== HostComponent);\n\n      if (inst) {\n        return inst;\n      }\n\n      return null;\n    }\n    /**\r\n     * Return the lowest common ancestor of A and B, or null if they are in\r\n     * different trees.\r\n     */\n\n\n    function getLowestCommonAncestor(instA, instB) {\n      var depthA = 0;\n\n      for (var tempA = instA; tempA; tempA = getParent(tempA)) {\n        depthA++;\n      }\n\n      var depthB = 0;\n\n      for (var tempB = instB; tempB; tempB = getParent(tempB)) {\n        depthB++;\n      } // If A is deeper, crawl up.\n\n\n      while (depthA - depthB > 0) {\n        instA = getParent(instA);\n        depthA--;\n      } // If B is deeper, crawl up.\n\n\n      while (depthB - depthA > 0) {\n        instB = getParent(instB);\n        depthB--;\n      } // Walk in lockstep until we find a match.\n\n\n      var depth = depthA;\n\n      while (depth--) {\n        if (instA === instB || instA === instB.alternate) {\n          return instA;\n        }\n\n        instA = getParent(instA);\n        instB = getParent(instB);\n      }\n\n      return null;\n    }\n    /**\r\n     * Return if A is an ancestor of B.\r\n     */\n\n\n    function isAncestor(instA, instB) {\n      while (instB) {\n        if (instA === instB || instA === instB.alternate) {\n          return true;\n        }\n\n        instB = getParent(instB);\n      }\n\n      return false;\n    }\n    /**\r\n     * Return the parent instance of the passed-in instance.\r\n     */\n\n\n    function getParentInstance(inst) {\n      return getParent(inst);\n    }\n    /**\r\n     * Simulates the traversal of a two-phase, capture/bubble event dispatch.\r\n     */\n\n\n    function traverseTwoPhase(inst, fn, arg) {\n      var path = [];\n\n      while (inst) {\n        path.push(inst);\n        inst = getParent(inst);\n      }\n\n      var i = void 0;\n\n      for (i = path.length; i-- > 0;) {\n        fn(path[i], 'captured', arg);\n      }\n\n      for (i = 0; i < path.length; i++) {\n        fn(path[i], 'bubbled', arg);\n      }\n    }\n    /**\r\n     * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\r\n     * should would receive a `mouseEnter` or `mouseLeave` event.\r\n     *\r\n     * Does not invoke the callback on the nearest common ancestor because nothing\r\n     * \"entered\" or \"left\" that element.\r\n     */\n\n    /**\r\n     * Registers plugins so that they can extract and dispatch events.\r\n     *\r\n     * @see {EventPluginHub}\r\n     */\n\n    /**\r\n     * Ordered list of injected plugins.\r\n     */\n\n    /**\r\n     * Mapping from event name to dispatch config\r\n     */\n\n    /**\r\n     * Mapping from registration name to plugin module\r\n     */\n\n    /**\r\n     * Mapping from registration name to event name\r\n     */\n\n    /**\r\n     * Mapping from lowercase registration names to the properly cased version,\r\n     * used to warn in the case of missing event handlers. Available\r\n     * only in true.\r\n     * @type {Object}\r\n     */\n    // Trust the developer to only use possibleRegistrationNames in true\n\n    /**\r\n     * Injects an ordering of plugins (by plugin name). This allows the ordering\r\n     * to be decoupled from injection of the actual plugins so that ordering is\r\n     * always deterministic regardless of packaging, on-the-fly injection, etc.\r\n     *\r\n     * @param {array} InjectedEventPluginOrder\r\n     * @internal\r\n     * @see {EventPluginHub.injection.injectEventPluginOrder}\r\n     */\n\n    /**\r\n     * Injects plugins to be used by `EventPluginHub`. The plugin names must be\r\n     * in the ordering injected by `injectEventPluginOrder`.\r\n     *\r\n     * Plugins can be injected as part of page initialization or on-the-fly.\r\n     *\r\n     * @param {object} injectedNamesToPlugins Map from names to plugin modules.\r\n     * @internal\r\n     * @see {EventPluginHub.injection.injectEventPluginsByName}\r\n     */\n\n    /**\r\n     * Accumulates items that must not be null or undefined into the first one. This\r\n     * is used to conserve memory by avoiding array allocations, and thus sacrifices\r\n     * API cleanness. Since `current` can be null before being passed in and not\r\n     * null after this function, make sure to assign it back to `current`:\r\n     *\r\n     * `a = accumulateInto(a, b);`\r\n     *\r\n     * This API should be sparingly used. Try `accumulate` for something cleaner.\r\n     *\r\n     * @return {*|array<*>} An accumulation of items.\r\n     */\n\n\n    function accumulateInto(current, next) {\n      (function () {\n        if (!(next != null)) {\n          {\n            throw ReactError(Error('accumulateInto(...): Accumulated items must not be null or undefined.'));\n          }\n        }\n      })();\n\n      if (current == null) {\n        return next;\n      } // Both are not empty. Warning: Never call x.concat(y) when you are not\n      // certain that x is an Array (x could be a string with concat method).\n\n\n      if (Array.isArray(current)) {\n        if (Array.isArray(next)) {\n          current.push.apply(current, next);\n          return current;\n        }\n\n        current.push(next);\n        return current;\n      }\n\n      if (Array.isArray(next)) {\n        // A bit too dangerous to mutate `next`.\n        return [current].concat(next);\n      }\n\n      return [current, next];\n    }\n    /**\r\n     * @param {array} arr an \"accumulation\" of items which is either an Array or\r\n     * a single item. Useful when paired with the `accumulate` module. This is a\r\n     * simple utility that allows us to reason about a collection of items, but\r\n     * handling the case when there is exactly one item (and we do not need to\r\n     * allocate an array).\r\n     * @param {function} cb Callback invoked with each element or a collection.\r\n     * @param {?} [scope] Scope used as `this` in a callback.\r\n     */\n\n\n    function forEachAccumulated(arr, cb, scope) {\n      if (Array.isArray(arr)) {\n        arr.forEach(cb, scope);\n      } else if (arr) {\n        cb.call(scope, arr);\n      }\n    }\n\n    function isInteractive(tag) {\n      return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';\n    }\n\n    function shouldPreventMouseEvent(name, type, props) {\n      switch (name) {\n        case 'onClick':\n        case 'onClickCapture':\n        case 'onDoubleClick':\n        case 'onDoubleClickCapture':\n        case 'onMouseDown':\n        case 'onMouseDownCapture':\n        case 'onMouseMove':\n        case 'onMouseMoveCapture':\n        case 'onMouseUp':\n        case 'onMouseUpCapture':\n          return !!(props.disabled && isInteractive(type));\n\n        default:\n          return false;\n      }\n    }\n    /**\r\n     * This is a unified interface for event plugins to be installed and configured.\r\n     *\r\n     * Event plugins can implement the following properties:\r\n     *\r\n     *   `extractEvents` {function(string, DOMEventTarget, string, object): *}\r\n     *     Required. When a top-level event is fired, this method is expected to\r\n     *     extract synthetic events that will in turn be queued and dispatched.\r\n     *\r\n     *   `eventTypes` {object}\r\n     *     Optional, plugins that fire events must publish a mapping of registration\r\n     *     names that are used to register listeners. Values of this mapping must\r\n     *     be objects that contain `registrationName` or `phasedRegistrationNames`.\r\n     *\r\n     *   `executeDispatch` {function(object, function, string)}\r\n     *     Optional, allows plugins to override how an event gets dispatched. By\r\n     *     default, the listener is simply invoked.\r\n     *\r\n     * Each plugin that is injected into `EventsPluginHub` is immediately operable.\r\n     *\r\n     * @public\r\n     */\n\n    /**\r\n     * Methods for injecting dependencies.\r\n     */\n\n    /**\r\n     * @param {object} inst The instance, which is the source of events.\r\n     * @param {string} registrationName Name of listener (e.g. `onClick`).\r\n     * @return {?function} The stored callback.\r\n     */\n\n\n    function getListener(inst, registrationName) {\n      var listener = void 0; // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not\n      // live here; needs to be moved to a better place soon\n\n      var stateNode = inst.stateNode;\n\n      if (!stateNode) {\n        // Work in progress (ex: onload events in incremental mode).\n        return null;\n      }\n\n      var props = getFiberCurrentPropsFromNode$1(stateNode);\n\n      if (!props) {\n        // Work in progress.\n        return null;\n      }\n\n      listener = props[registrationName];\n\n      if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\n        return null;\n      }\n\n      (function () {\n        if (!(!listener || typeof listener === 'function')) {\n          {\n            throw ReactError(Error('Expected `' + registrationName + '` listener to be a function, instead got a value of `' + typeof listener + '` type.'));\n          }\n        }\n      })();\n\n      return listener;\n    }\n    /**\r\n     * Some event types have a notion of different registration names for different\r\n     * \"phases\" of propagation. This finds listeners by a given phase.\r\n     */\n\n\n    function listenerAtPhase(inst, event, propagationPhase) {\n      var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n      return getListener(inst, registrationName);\n    }\n    /**\r\n     * A small set of propagation patterns, each of which will accept a small amount\r\n     * of information, and generate a set of \"dispatch ready event objects\" - which\r\n     * are sets of events that have already been annotated with a set of dispatched\r\n     * listener functions/ids. The API is designed this way to discourage these\r\n     * propagation strategies from actually executing the dispatches, since we\r\n     * always want to collect the entire set of dispatches before executing even a\r\n     * single one.\r\n     */\n\n    /**\r\n     * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\r\n     * here, allows us to not have to bind or create functions for each event.\r\n     * Mutating the event's members allows us to not have to create a wrapping\r\n     * \"dispatch\" object that pairs the event with the listener.\r\n     */\n\n\n    function accumulateDirectionalDispatches(inst, phase, event) {\n      {\n        !inst ? warningWithoutStack$1(false, 'Dispatching inst must not be null') : void 0;\n      }\n      var listener = listenerAtPhase(inst, event, phase);\n\n      if (listener) {\n        event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n        event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n      }\n    }\n    /**\r\n     * Collect dispatches (must be entirely collected before dispatching - see unit\r\n     * tests). Lazily allocate the array to conserve memory.  We must loop through\r\n     * each event and perform the traversal for each one. We cannot perform a\r\n     * single traversal for the entire collection of events because each event may\r\n     * have a different target.\r\n     */\n\n\n    function accumulateTwoPhaseDispatchesSingle(event) {\n      if (event && event.dispatchConfig.phasedRegistrationNames) {\n        traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n      }\n    }\n    /**\r\n     * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\r\n     */\n\n\n    function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n      if (event && event.dispatchConfig.phasedRegistrationNames) {\n        var targetInst = event._targetInst;\n        var parentInst = targetInst ? getParentInstance(targetInst) : null;\n        traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n      }\n    }\n    /**\r\n     * Accumulates without regard to direction, does not look for phased\r\n     * registration names. Same as `accumulateDirectDispatchesSingle` but without\r\n     * requiring that the `dispatchMarker` be the same as the dispatched ID.\r\n     */\n\n\n    function accumulateDispatches(inst, ignoredDirection, event) {\n      if (inst && event && event.dispatchConfig.registrationName) {\n        var registrationName = event.dispatchConfig.registrationName;\n        var listener = getListener(inst, registrationName);\n\n        if (listener) {\n          event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n          event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n        }\n      }\n    }\n    /**\r\n     * Accumulates dispatches on an `SyntheticEvent`, but only for the\r\n     * `dispatchMarker`.\r\n     * @param {SyntheticEvent} event\r\n     */\n\n\n    function accumulateDirectDispatchesSingle(event) {\n      if (event && event.dispatchConfig.registrationName) {\n        accumulateDispatches(event._targetInst, null, event);\n      }\n    }\n\n    function accumulateTwoPhaseDispatches(events) {\n      forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n    }\n\n    function accumulateTwoPhaseDispatchesSkipTarget(events) {\n      forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n    }\n\n    function accumulateDirectDispatches(events) {\n      forEachAccumulated(events, accumulateDirectDispatchesSingle);\n    }\n    /* eslint valid-typeof: 0 */\n\n\n    var EVENT_POOL_SIZE = 10;\n    /**\r\n     * @interface Event\r\n     * @see http://www.w3.org/TR/DOM-Level-3-Events/\r\n     */\n\n    var EventInterface = {\n      type: null,\n      target: null,\n      // currentTarget is set when dispatching; no use in copying it here\n      currentTarget: function () {\n        return null;\n      },\n      eventPhase: null,\n      bubbles: null,\n      cancelable: null,\n      timeStamp: function (event) {\n        return event.timeStamp || Date.now();\n      },\n      defaultPrevented: null,\n      isTrusted: null\n    };\n\n    function functionThatReturnsTrue() {\n      return true;\n    }\n\n    function functionThatReturnsFalse() {\n      return false;\n    }\n    /**\r\n     * Synthetic events are dispatched by event plugins, typically in response to a\r\n     * top-level event delegation handler.\r\n     *\r\n     * These systems should generally use pooling to reduce the frequency of garbage\r\n     * collection. The system should check `isPersistent` to determine whether the\r\n     * event should be released into the pool after being dispatched. Users that\r\n     * need a persisted event should invoke `persist`.\r\n     *\r\n     * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\r\n     * normalizing browser quirks. Subclasses do not necessarily have to implement a\r\n     * DOM interface; custom application-specific events can also subclass this.\r\n     *\r\n     * @param {object} dispatchConfig Configuration used to dispatch this event.\r\n     * @param {*} targetInst Marker identifying the event target.\r\n     * @param {object} nativeEvent Native browser event.\r\n     * @param {DOMEventTarget} nativeEventTarget Target node.\r\n     */\n\n\n    function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {\n      {\n        // these have a getter/setter for warnings\n        delete this.nativeEvent;\n        delete this.preventDefault;\n        delete this.stopPropagation;\n        delete this.isDefaultPrevented;\n        delete this.isPropagationStopped;\n      }\n      this.dispatchConfig = dispatchConfig;\n      this._targetInst = targetInst;\n      this.nativeEvent = nativeEvent;\n      var Interface = this.constructor.Interface;\n\n      for (var propName in Interface) {\n        if (!Interface.hasOwnProperty(propName)) {\n          continue;\n        }\n\n        {\n          delete this[propName]; // this has a getter/setter for warnings\n        }\n        var normalize = Interface[propName];\n\n        if (normalize) {\n          this[propName] = normalize(nativeEvent);\n        } else {\n          if (propName === 'target') {\n            this.target = nativeEventTarget;\n          } else {\n            this[propName] = nativeEvent[propName];\n          }\n        }\n      }\n\n      var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;\n\n      if (defaultPrevented) {\n        this.isDefaultPrevented = functionThatReturnsTrue;\n      } else {\n        this.isDefaultPrevented = functionThatReturnsFalse;\n      }\n\n      this.isPropagationStopped = functionThatReturnsFalse;\n      return this;\n    }\n\n    _assign(SyntheticEvent.prototype, {\n      preventDefault: function () {\n        this.defaultPrevented = true;\n        var event = this.nativeEvent;\n\n        if (!event) {\n          return;\n        }\n\n        if (event.preventDefault) {\n          event.preventDefault();\n        } else if (typeof event.returnValue !== 'unknown') {\n          event.returnValue = false;\n        }\n\n        this.isDefaultPrevented = functionThatReturnsTrue;\n      },\n      stopPropagation: function () {\n        var event = this.nativeEvent;\n\n        if (!event) {\n          return;\n        }\n\n        if (event.stopPropagation) {\n          event.stopPropagation();\n        } else if (typeof event.cancelBubble !== 'unknown') {\n          // The ChangeEventPlugin registers a \"propertychange\" event for\n          // IE. This event does not support bubbling or cancelling, and\n          // any references to cancelBubble throw \"Member not found\".  A\n          // typeof check of \"unknown\" circumvents this issue (and is also\n          // IE specific).\n          event.cancelBubble = true;\n        }\n\n        this.isPropagationStopped = functionThatReturnsTrue;\n      },\n\n      /**\r\n       * We release all dispatched `SyntheticEvent`s after each event loop, adding\r\n       * them back into the pool. This allows a way to hold onto a reference that\r\n       * won't be added back into the pool.\r\n       */\n      persist: function () {\n        this.isPersistent = functionThatReturnsTrue;\n      },\n\n      /**\r\n       * Checks if this event should be released back into the pool.\r\n       *\r\n       * @return {boolean} True if this should not be released, false otherwise.\r\n       */\n      isPersistent: functionThatReturnsFalse,\n\n      /**\r\n       * `PooledClass` looks for `destructor` on each instance it releases.\r\n       */\n      destructor: function () {\n        var Interface = this.constructor.Interface;\n\n        for (var propName in Interface) {\n          {\n            Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));\n          }\n        }\n\n        this.dispatchConfig = null;\n        this._targetInst = null;\n        this.nativeEvent = null;\n        this.isDefaultPrevented = functionThatReturnsFalse;\n        this.isPropagationStopped = functionThatReturnsFalse;\n        this._dispatchListeners = null;\n        this._dispatchInstances = null;\n        {\n          Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));\n          Object.defineProperty(this, 'isDefaultPrevented', getPooledWarningPropertyDefinition('isDefaultPrevented', functionThatReturnsFalse));\n          Object.defineProperty(this, 'isPropagationStopped', getPooledWarningPropertyDefinition('isPropagationStopped', functionThatReturnsFalse));\n          Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', function () {}));\n          Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', function () {}));\n        }\n      }\n    });\n\n    SyntheticEvent.Interface = EventInterface;\n    /**\r\n     * Helper to reduce boilerplate when creating subclasses.\r\n     */\n\n    SyntheticEvent.extend = function (Interface) {\n      var Super = this;\n\n      var E = function () {};\n\n      E.prototype = Super.prototype;\n      var prototype = new E();\n\n      function Class() {\n        return Super.apply(this, arguments);\n      }\n\n      _assign(prototype, Class.prototype);\n\n      Class.prototype = prototype;\n      Class.prototype.constructor = Class;\n      Class.Interface = _assign({}, Super.Interface, Interface);\n      Class.extend = Super.extend;\n      addEventPoolingTo(Class);\n      return Class;\n    };\n\n    addEventPoolingTo(SyntheticEvent);\n    /**\r\n     * Helper to nullify syntheticEvent instance properties when destructing\r\n     *\r\n     * @param {String} propName\r\n     * @param {?object} getVal\r\n     * @return {object} defineProperty object\r\n     */\n\n    function getPooledWarningPropertyDefinition(propName, getVal) {\n      var isFunction = typeof getVal === 'function';\n      return {\n        configurable: true,\n        set: set,\n        get: get\n      };\n\n      function set(val) {\n        var action = isFunction ? 'setting the method' : 'setting the property';\n        warn(action, 'This is effectively a no-op');\n        return val;\n      }\n\n      function get() {\n        var action = isFunction ? 'accessing the method' : 'accessing the property';\n        var result = isFunction ? 'This is a no-op function' : 'This is set to null';\n        warn(action, result);\n        return getVal;\n      }\n\n      function warn(action, result) {\n        var warningCondition = false;\n        !warningCondition ? warningWithoutStack$1(false, \"This synthetic event is reused for performance reasons. If you're seeing this, \" + \"you're %s `%s` on a released/nullified synthetic event. %s. \" + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;\n      }\n    }\n\n    function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {\n      var EventConstructor = this;\n\n      if (EventConstructor.eventPool.length) {\n        var instance = EventConstructor.eventPool.pop();\n        EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);\n        return instance;\n      }\n\n      return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);\n    }\n\n    function releasePooledEvent(event) {\n      var EventConstructor = this;\n\n      (function () {\n        if (!(event instanceof EventConstructor)) {\n          {\n            throw ReactError(Error('Trying to release an event instance into a pool of a different type.'));\n          }\n        }\n      })();\n\n      event.destructor();\n\n      if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {\n        EventConstructor.eventPool.push(event);\n      }\n    }\n\n    function addEventPoolingTo(EventConstructor) {\n      EventConstructor.eventPool = [];\n      EventConstructor.getPooled = getPooledEvent;\n      EventConstructor.release = releasePooledEvent;\n    }\n    /**\r\n     * `touchHistory` isn't actually on the native event, but putting it in the\r\n     * interface will ensure that it is cleaned up when pooled/destroyed. The\r\n     * `ResponderEventPlugin` will populate it appropriately.\r\n     */\n\n\n    var ResponderSyntheticEvent = SyntheticEvent.extend({\n      touchHistory: function (nativeEvent) {\n        return null; // Actually doesn't even look at the native event.\n      }\n    }); // Note: ideally these would be imported from DOMTopLevelEventTypes,\n    // but our build system currently doesn't let us do that from a fork.\n\n    var TOP_TOUCH_START = 'touchstart';\n    var TOP_TOUCH_MOVE = 'touchmove';\n    var TOP_TOUCH_END = 'touchend';\n    var TOP_TOUCH_CANCEL = 'touchcancel';\n    var TOP_SCROLL = 'scroll';\n    var TOP_SELECTION_CHANGE = 'selectionchange';\n    var TOP_MOUSE_DOWN = 'mousedown';\n    var TOP_MOUSE_MOVE = 'mousemove';\n    var TOP_MOUSE_UP = 'mouseup';\n\n    function isStartish(topLevelType) {\n      return topLevelType === TOP_TOUCH_START || topLevelType === TOP_MOUSE_DOWN;\n    }\n\n    function isMoveish(topLevelType) {\n      return topLevelType === TOP_TOUCH_MOVE || topLevelType === TOP_MOUSE_MOVE;\n    }\n\n    function isEndish(topLevelType) {\n      return topLevelType === TOP_TOUCH_END || topLevelType === TOP_TOUCH_CANCEL || topLevelType === TOP_MOUSE_UP;\n    }\n\n    var startDependencies = [TOP_TOUCH_START, TOP_MOUSE_DOWN];\n    var moveDependencies = [TOP_TOUCH_MOVE, TOP_MOUSE_MOVE];\n    var endDependencies = [TOP_TOUCH_CANCEL, TOP_TOUCH_END, TOP_MOUSE_UP];\n    /**\r\n     * Tracks the position and time of each active touch by `touch.identifier`. We\r\n     * should typically only see IDs in the range of 1-20 because IDs get recycled\r\n     * when touches end and start again.\r\n     */\n\n    var MAX_TOUCH_BANK = 20;\n    var touchBank = [];\n    var touchHistory = {\n      touchBank: touchBank,\n      numberActiveTouches: 0,\n      // If there is only one active touch, we remember its location. This prevents\n      // us having to loop through all of the touches all the time in the most\n      // common case.\n      indexOfSingleActiveTouch: -1,\n      mostRecentTimeStamp: 0\n    };\n\n    function timestampForTouch(touch) {\n      // The legacy internal implementation provides \"timeStamp\", which has been\n      // renamed to \"timestamp\". Let both work for now while we iron it out\n      // TODO (evv): rename timeStamp to timestamp in internal code\n      return touch.timeStamp || touch.timestamp;\n    }\n    /**\r\n     * TODO: Instead of making gestures recompute filtered velocity, we could\r\n     * include a built in velocity computation that can be reused globally.\r\n     */\n\n\n    function createTouchRecord(touch) {\n      return {\n        touchActive: true,\n        startPageX: touch.pageX,\n        startPageY: touch.pageY,\n        startTimeStamp: timestampForTouch(touch),\n        currentPageX: touch.pageX,\n        currentPageY: touch.pageY,\n        currentTimeStamp: timestampForTouch(touch),\n        previousPageX: touch.pageX,\n        previousPageY: touch.pageY,\n        previousTimeStamp: timestampForTouch(touch)\n      };\n    }\n\n    function resetTouchRecord(touchRecord, touch) {\n      touchRecord.touchActive = true;\n      touchRecord.startPageX = touch.pageX;\n      touchRecord.startPageY = touch.pageY;\n      touchRecord.startTimeStamp = timestampForTouch(touch);\n      touchRecord.currentPageX = touch.pageX;\n      touchRecord.currentPageY = touch.pageY;\n      touchRecord.currentTimeStamp = timestampForTouch(touch);\n      touchRecord.previousPageX = touch.pageX;\n      touchRecord.previousPageY = touch.pageY;\n      touchRecord.previousTimeStamp = timestampForTouch(touch);\n    }\n\n    function getTouchIdentifier(_ref) {\n      var identifier = _ref.identifier;\n\n      (function () {\n        if (!(identifier != null)) {\n          {\n            throw ReactError(Error('Touch object is missing identifier.'));\n          }\n        }\n      })();\n\n      {\n        !(identifier <= MAX_TOUCH_BANK) ? warningWithoutStack$1(false, 'Touch identifier %s is greater than maximum supported %s which causes ' + 'performance issues backfilling array locations for all of the indices.', identifier, MAX_TOUCH_BANK) : void 0;\n      }\n      return identifier;\n    }\n\n    function recordTouchStart(touch) {\n      var identifier = getTouchIdentifier(touch);\n      var touchRecord = touchBank[identifier];\n\n      if (touchRecord) {\n        resetTouchRecord(touchRecord, touch);\n      } else {\n        touchBank[identifier] = createTouchRecord(touch);\n      }\n\n      touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n    }\n\n    function recordTouchMove(touch) {\n      var touchRecord = touchBank[getTouchIdentifier(touch)];\n\n      if (touchRecord) {\n        touchRecord.touchActive = true;\n        touchRecord.previousPageX = touchRecord.currentPageX;\n        touchRecord.previousPageY = touchRecord.currentPageY;\n        touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n        touchRecord.currentPageX = touch.pageX;\n        touchRecord.currentPageY = touch.pageY;\n        touchRecord.currentTimeStamp = timestampForTouch(touch);\n        touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n      } else {\n        console.warn('Cannot record touch move without a touch start.\\n' + 'Touch Move: %s\\n', 'Touch Bank: %s', printTouch(touch), printTouchBank());\n      }\n    }\n\n    function recordTouchEnd(touch) {\n      var touchRecord = touchBank[getTouchIdentifier(touch)];\n\n      if (touchRecord) {\n        touchRecord.touchActive = false;\n        touchRecord.previousPageX = touchRecord.currentPageX;\n        touchRecord.previousPageY = touchRecord.currentPageY;\n        touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n        touchRecord.currentPageX = touch.pageX;\n        touchRecord.currentPageY = touch.pageY;\n        touchRecord.currentTimeStamp = timestampForTouch(touch);\n        touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n      } else {\n        console.warn('Cannot record touch end without a touch start.\\n' + 'Touch End: %s\\n', 'Touch Bank: %s', printTouch(touch), printTouchBank());\n      }\n    }\n\n    function printTouch(touch) {\n      return JSON.stringify({\n        identifier: touch.identifier,\n        pageX: touch.pageX,\n        pageY: touch.pageY,\n        timestamp: timestampForTouch(touch)\n      });\n    }\n\n    function printTouchBank() {\n      var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));\n\n      if (touchBank.length > MAX_TOUCH_BANK) {\n        printed += ' (original size: ' + touchBank.length + ')';\n      }\n\n      return printed;\n    }\n\n    var ResponderTouchHistoryStore = {\n      recordTouchTrack: function (topLevelType, nativeEvent) {\n        if (isMoveish(topLevelType)) {\n          nativeEvent.changedTouches.forEach(recordTouchMove);\n        } else if (isStartish(topLevelType)) {\n          nativeEvent.changedTouches.forEach(recordTouchStart);\n          touchHistory.numberActiveTouches = nativeEvent.touches.length;\n\n          if (touchHistory.numberActiveTouches === 1) {\n            touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;\n          }\n        } else if (isEndish(topLevelType)) {\n          nativeEvent.changedTouches.forEach(recordTouchEnd);\n          touchHistory.numberActiveTouches = nativeEvent.touches.length;\n\n          if (touchHistory.numberActiveTouches === 1) {\n            for (var i = 0; i < touchBank.length; i++) {\n              var touchTrackToCheck = touchBank[i];\n\n              if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {\n                touchHistory.indexOfSingleActiveTouch = i;\n                break;\n              }\n            }\n\n            {\n              var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];\n              !(activeRecord != null && activeRecord.touchActive) ? warningWithoutStack$1(false, 'Cannot find single active touch.') : void 0;\n            }\n          }\n        }\n      },\n      touchHistory: touchHistory\n    };\n    /**\r\n     * Accumulates items that must not be null or undefined.\r\n     *\r\n     * This is used to conserve memory by avoiding array allocations.\r\n     *\r\n     * @return {*|array<*>} An accumulation of items.\r\n     */\n\n    function accumulate(current, next) {\n      (function () {\n        if (!(next != null)) {\n          {\n            throw ReactError(Error('accumulate(...): Accumulated items must not be null or undefined.'));\n          }\n        }\n      })();\n\n      if (current == null) {\n        return next;\n      } // Both are not empty. Warning: Never call x.concat(y) when you are not\n      // certain that x is an Array (x could be a string with concat method).\n\n\n      if (Array.isArray(current)) {\n        return current.concat(next);\n      }\n\n      if (Array.isArray(next)) {\n        return [current].concat(next);\n      }\n\n      return [current, next];\n    }\n    /**\r\n     * Instance of element that should respond to touch/move types of interactions,\r\n     * as indicated explicitly by relevant callbacks.\r\n     */\n\n\n    var responderInst = null;\n    /**\r\n     * Count of current touches. A textInput should become responder iff the\r\n     * selection changes while there is a touch on the screen.\r\n     */\n\n    var trackedTouchCount = 0;\n\n    var changeResponder = function (nextResponderInst, blockHostResponder) {\n      var oldResponderInst = responderInst;\n      responderInst = nextResponderInst;\n\n      if (ResponderEventPlugin.GlobalResponderHandler !== null) {\n        ResponderEventPlugin.GlobalResponderHandler.onChange(oldResponderInst, nextResponderInst, blockHostResponder);\n      }\n    };\n\n    var eventTypes = {\n      /**\r\n       * On a `touchStart`/`mouseDown`, is it desired that this element become the\r\n       * responder?\r\n       */\n      startShouldSetResponder: {\n        phasedRegistrationNames: {\n          bubbled: 'onStartShouldSetResponder',\n          captured: 'onStartShouldSetResponderCapture'\n        },\n        dependencies: startDependencies\n      },\n\n      /**\r\n       * On a `scroll`, is it desired that this element become the responder? This\r\n       * is usually not needed, but should be used to retroactively infer that a\r\n       * `touchStart` had occurred during momentum scroll. During a momentum scroll,\r\n       * a touch start will be immediately followed by a scroll event if the view is\r\n       * currently scrolling.\r\n       *\r\n       * TODO: This shouldn't bubble.\r\n       */\n      scrollShouldSetResponder: {\n        phasedRegistrationNames: {\n          bubbled: 'onScrollShouldSetResponder',\n          captured: 'onScrollShouldSetResponderCapture'\n        },\n        dependencies: [TOP_SCROLL]\n      },\n\n      /**\r\n       * On text selection change, should this element become the responder? This\r\n       * is needed for text inputs or other views with native selection, so the\r\n       * JS view can claim the responder.\r\n       *\r\n       * TODO: This shouldn't bubble.\r\n       */\n      selectionChangeShouldSetResponder: {\n        phasedRegistrationNames: {\n          bubbled: 'onSelectionChangeShouldSetResponder',\n          captured: 'onSelectionChangeShouldSetResponderCapture'\n        },\n        dependencies: [TOP_SELECTION_CHANGE]\n      },\n\n      /**\r\n       * On a `touchMove`/`mouseMove`, is it desired that this element become the\r\n       * responder?\r\n       */\n      moveShouldSetResponder: {\n        phasedRegistrationNames: {\n          bubbled: 'onMoveShouldSetResponder',\n          captured: 'onMoveShouldSetResponderCapture'\n        },\n        dependencies: moveDependencies\n      },\n\n      /**\r\n       * Direct responder events dispatched directly to responder. Do not bubble.\r\n       */\n      responderStart: {\n        registrationName: 'onResponderStart',\n        dependencies: startDependencies\n      },\n      responderMove: {\n        registrationName: 'onResponderMove',\n        dependencies: moveDependencies\n      },\n      responderEnd: {\n        registrationName: 'onResponderEnd',\n        dependencies: endDependencies\n      },\n      responderRelease: {\n        registrationName: 'onResponderRelease',\n        dependencies: endDependencies\n      },\n      responderTerminationRequest: {\n        registrationName: 'onResponderTerminationRequest',\n        dependencies: []\n      },\n      responderGrant: {\n        registrationName: 'onResponderGrant',\n        dependencies: []\n      },\n      responderReject: {\n        registrationName: 'onResponderReject',\n        dependencies: []\n      },\n      responderTerminate: {\n        registrationName: 'onResponderTerminate',\n        dependencies: []\n      }\n    };\n    /**\r\n     *\r\n     * Responder System:\r\n     * ----------------\r\n     *\r\n     * - A global, solitary \"interaction lock\" on a view.\r\n     * - If a node becomes the responder, it should convey visual feedback\r\n     *   immediately to indicate so, either by highlighting or moving accordingly.\r\n     * - To be the responder means, that touches are exclusively important to that\r\n     *   responder view, and no other view.\r\n     * - While touches are still occurring, the responder lock can be transferred to\r\n     *   a new view, but only to increasingly \"higher\" views (meaning ancestors of\r\n     *   the current responder).\r\n     *\r\n     * Responder being granted:\r\n     * ------------------------\r\n     *\r\n     * - Touch starts, moves, and scrolls can cause an ID to become the responder.\r\n     * - We capture/bubble `startShouldSetResponder`/`moveShouldSetResponder` to\r\n     *   the \"appropriate place\".\r\n     * - If nothing is currently the responder, the \"appropriate place\" is the\r\n     *   initiating event's `targetID`.\r\n     * - If something *is* already the responder, the \"appropriate place\" is the\r\n     *   first common ancestor of the event target and the current `responderInst`.\r\n     * - Some negotiation happens: See the timing diagram below.\r\n     * - Scrolled views automatically become responder. The reasoning is that a\r\n     *   platform scroll view that isn't built on top of the responder system has\r\n     *   began scrolling, and the active responder must now be notified that the\r\n     *   interaction is no longer locked to it - the system has taken over.\r\n     *\r\n     * - Responder being released:\r\n     *   As soon as no more touches that *started* inside of descendants of the\r\n     *   *current* responderInst, an `onResponderRelease` event is dispatched to the\r\n     *   current responder, and the responder lock is released.\r\n     *\r\n     * TODO:\r\n     * - on \"end\", a callback hook for `onResponderEndShouldRemainResponder` that\r\n     *   determines if the responder lock should remain.\r\n     * - If a view shouldn't \"remain\" the responder, any active touches should by\r\n     *   default be considered \"dead\" and do not influence future negotiations or\r\n     *   bubble paths. It should be as if those touches do not exist.\r\n     * -- For multitouch: Usually a translate-z will choose to \"remain\" responder\r\n     *  after one out of many touches ended. For translate-y, usually the view\r\n     *  doesn't wish to \"remain\" responder after one of many touches end.\r\n     * - Consider building this on top of a `stopPropagation` model similar to\r\n     *   `W3C` events.\r\n     * - Ensure that `onResponderTerminate` is called on touch cancels, whether or\r\n     *   not `onResponderTerminationRequest` returns `true` or `false`.\r\n     *\r\n     */\n\n    /*                                             Negotiation Performed\r\n                                                 +-----------------------+\r\n                                                /                         \\\r\n    Process low level events to    +     Current Responder      +   wantsResponderID\r\n    determine who to perform negot-|   (if any exists at all)   |\r\n    iation/transition              | Otherwise just pass through|\r\n    -------------------------------+----------------------------+------------------+\r\n    Bubble to find first ID        |                            |\r\n    to return true:wantsResponderID|                            |\r\n                                   |                            |\r\n         +-------------+           |                            |\r\n         | onTouchStart|           |                            |\r\n         +------+------+     none  |                            |\r\n                |            return|                            |\r\n    +-----------v-------------+true| +------------------------+ |\r\n    |onStartShouldSetResponder|----->|onResponderStart (cur)  |<-----------+\r\n    +-----------+-------------+    | +------------------------+ |          |\r\n                |                  |                            | +--------+-------+\r\n                | returned true for|       false:REJECT +-------->|onResponderReject\r\n                | wantsResponderID |                    |       | +----------------+\r\n                | (now attempt     | +------------------+-----+ |\r\n                |  handoff)        | |   onResponder          | |\r\n                +------------------->|      TerminationRequest| |\r\n                                   | +------------------+-----+ |\r\n                                   |                    |       | +----------------+\r\n                                   |         true:GRANT +-------->|onResponderGrant|\r\n                                   |                            | +--------+-------+\r\n                                   | +------------------------+ |          |\r\n                                   | |   onResponderTerminate |<-----------+\r\n                                   | +------------------+-----+ |\r\n                                   |                    |       | +----------------+\r\n                                   |                    +-------->|onResponderStart|\r\n                                   |                            | +----------------+\r\n    Bubble to find first ID        |                            |\r\n    to return true:wantsResponderID|                            |\r\n                                   |                            |\r\n         +-------------+           |                            |\r\n         | onTouchMove |           |                            |\r\n         +------+------+     none  |                            |\r\n                |            return|                            |\r\n    +-----------v-------------+true| +------------------------+ |\r\n    |onMoveShouldSetResponder |----->|onResponderMove (cur)   |<-----------+\r\n    +-----------+-------------+    | +------------------------+ |          |\r\n                |                  |                            | +--------+-------+\r\n                | returned true for|       false:REJECT +-------->|onResponderRejec|\r\n                | wantsResponderID |                    |       | +----------------+\r\n                | (now attempt     | +------------------+-----+ |\r\n                |  handoff)        | |   onResponder          | |\r\n                +------------------->|      TerminationRequest| |\r\n                                   | +------------------+-----+ |\r\n                                   |                    |       | +----------------+\r\n                                   |         true:GRANT +-------->|onResponderGrant|\r\n                                   |                            | +--------+-------+\r\n                                   | +------------------------+ |          |\r\n                                   | |   onResponderTerminate |<-----------+\r\n                                   | +------------------+-----+ |\r\n                                   |                    |       | +----------------+\r\n                                   |                    +-------->|onResponderMove |\r\n                                   |                            | +----------------+\r\n                                   |                            |\r\n                                   |                            |\r\n          Some active touch started|                            |\r\n          inside current responder | +------------------------+ |\r\n          +------------------------->|      onResponderEnd    | |\r\n          |                        | +------------------------+ |\r\n      +---+---------+              |                            |\r\n      | onTouchEnd  |              |                            |\r\n      +---+---------+              |                            |\r\n          |                        | +------------------------+ |\r\n          +------------------------->|     onResponderEnd     | |\r\n          No active touches started| +-----------+------------+ |\r\n          inside current responder |             |              |\r\n                                   |             v              |\r\n                                   | +------------------------+ |\r\n                                   | |    onResponderRelease  | |\r\n                                   | +------------------------+ |\r\n                                   |                            |\r\n                                   +                            + */\n\n    /**\r\n     * A note about event ordering in the `EventPluginHub`.\r\n     *\r\n     * Suppose plugins are injected in the following order:\r\n     *\r\n     * `[R, S, C]`\r\n     *\r\n     * To help illustrate the example, assume `S` is `SimpleEventPlugin` (for\r\n     * `onClick` etc) and `R` is `ResponderEventPlugin`.\r\n     *\r\n     * \"Deferred-Dispatched Events\":\r\n     *\r\n     * - The current event plugin system will traverse the list of injected plugins,\r\n     *   in order, and extract events by collecting the plugin's return value of\r\n     *   `extractEvents()`.\r\n     * - These events that are returned from `extractEvents` are \"deferred\r\n     *   dispatched events\".\r\n     * - When returned from `extractEvents`, deferred-dispatched events contain an\r\n     *   \"accumulation\" of deferred dispatches.\r\n     * - These deferred dispatches are accumulated/collected before they are\r\n     *   returned, but processed at a later time by the `EventPluginHub` (hence the\r\n     *   name deferred).\r\n     *\r\n     * In the process of returning their deferred-dispatched events, event plugins\r\n     * themselves can dispatch events on-demand without returning them from\r\n     * `extractEvents`. Plugins might want to do this, so that they can use event\r\n     * dispatching as a tool that helps them decide which events should be extracted\r\n     * in the first place.\r\n     *\r\n     * \"On-Demand-Dispatched Events\":\r\n     *\r\n     * - On-demand-dispatched events are not returned from `extractEvents`.\r\n     * - On-demand-dispatched events are dispatched during the process of returning\r\n     *   the deferred-dispatched events.\r\n     * - They should not have side effects.\r\n     * - They should be avoided, and/or eventually be replaced with another\r\n     *   abstraction that allows event plugins to perform multiple \"rounds\" of event\r\n     *   extraction.\r\n     *\r\n     * Therefore, the sequence of event dispatches becomes:\r\n     *\r\n     * - `R`s on-demand events (if any)   (dispatched by `R` on-demand)\r\n     * - `S`s on-demand events (if any)   (dispatched by `S` on-demand)\r\n     * - `C`s on-demand events (if any)   (dispatched by `C` on-demand)\r\n     * - `R`s extracted events (if any)   (dispatched by `EventPluginHub`)\r\n     * - `S`s extracted events (if any)   (dispatched by `EventPluginHub`)\r\n     * - `C`s extracted events (if any)   (dispatched by `EventPluginHub`)\r\n     *\r\n     * In the case of `ResponderEventPlugin`: If the `startShouldSetResponder`\r\n     * on-demand dispatch returns `true` (and some other details are satisfied) the\r\n     * `onResponderGrant` deferred dispatched event is returned from\r\n     * `extractEvents`. The sequence of dispatch executions in this case\r\n     * will appear as follows:\r\n     *\r\n     * - `startShouldSetResponder` (`ResponderEventPlugin` dispatches on-demand)\r\n     * - `touchStartCapture`       (`EventPluginHub` dispatches as usual)\r\n     * - `touchStart`              (`EventPluginHub` dispatches as usual)\r\n     * - `responderGrant/Reject`   (`EventPluginHub` dispatches as usual)\r\n     */\n\n    function setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n      var shouldSetEventType = isStartish(topLevelType) ? eventTypes.startShouldSetResponder : isMoveish(topLevelType) ? eventTypes.moveShouldSetResponder : topLevelType === TOP_SELECTION_CHANGE ? eventTypes.selectionChangeShouldSetResponder : eventTypes.scrollShouldSetResponder; // TODO: stop one short of the current responder.\n\n      var bubbleShouldSetFrom = !responderInst ? targetInst : getLowestCommonAncestor(responderInst, targetInst); // When capturing/bubbling the \"shouldSet\" event, we want to skip the target\n      // (deepest ID) if it happens to be the current responder. The reasoning:\n      // It's strange to get an `onMoveShouldSetResponder` when you're *already*\n      // the responder.\n\n      var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;\n      var shouldSetEvent = ResponderSyntheticEvent.getPooled(shouldSetEventType, bubbleShouldSetFrom, nativeEvent, nativeEventTarget);\n      shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n\n      if (skipOverBubbleShouldSetFrom) {\n        accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);\n      } else {\n        accumulateTwoPhaseDispatches(shouldSetEvent);\n      }\n\n      var wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);\n\n      if (!shouldSetEvent.isPersistent()) {\n        shouldSetEvent.constructor.release(shouldSetEvent);\n      }\n\n      if (!wantsResponderInst || wantsResponderInst === responderInst) {\n        return null;\n      }\n\n      var extracted = void 0;\n      var grantEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderGrant, wantsResponderInst, nativeEvent, nativeEventTarget);\n      grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(grantEvent);\n      var blockHostResponder = executeDirectDispatch(grantEvent) === true;\n\n      if (responderInst) {\n        var terminationRequestEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderTerminationRequest, responderInst, nativeEvent, nativeEventTarget);\n        terminationRequestEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n        accumulateDirectDispatches(terminationRequestEvent);\n        var shouldSwitch = !hasDispatches(terminationRequestEvent) || executeDirectDispatch(terminationRequestEvent);\n\n        if (!terminationRequestEvent.isPersistent()) {\n          terminationRequestEvent.constructor.release(terminationRequestEvent);\n        }\n\n        if (shouldSwitch) {\n          var terminateEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderTerminate, responderInst, nativeEvent, nativeEventTarget);\n          terminateEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n          accumulateDirectDispatches(terminateEvent);\n          extracted = accumulate(extracted, [grantEvent, terminateEvent]);\n          changeResponder(wantsResponderInst, blockHostResponder);\n        } else {\n          var rejectEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderReject, wantsResponderInst, nativeEvent, nativeEventTarget);\n          rejectEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n          accumulateDirectDispatches(rejectEvent);\n          extracted = accumulate(extracted, rejectEvent);\n        }\n      } else {\n        extracted = accumulate(extracted, grantEvent);\n        changeResponder(wantsResponderInst, blockHostResponder);\n      }\n\n      return extracted;\n    }\n    /**\r\n     * A transfer is a negotiation between a currently set responder and the next\r\n     * element to claim responder status. Any start event could trigger a transfer\r\n     * of responderInst. Any move event could trigger a transfer.\r\n     *\r\n     * @param {string} topLevelType Record from `BrowserEventConstants`.\r\n     * @return {boolean} True if a transfer of responder could possibly occur.\r\n     */\n\n\n    function canTriggerTransfer(topLevelType, topLevelInst, nativeEvent) {\n      return topLevelInst && ( // responderIgnoreScroll: We are trying to migrate away from specifically\n      // tracking native scroll events here and responderIgnoreScroll indicates we\n      // will send topTouchCancel to handle canceling touch events instead\n      topLevelType === TOP_SCROLL && !nativeEvent.responderIgnoreScroll || trackedTouchCount > 0 && topLevelType === TOP_SELECTION_CHANGE || isStartish(topLevelType) || isMoveish(topLevelType));\n    }\n    /**\r\n     * Returns whether or not this touch end event makes it such that there are no\r\n     * longer any touches that started inside of the current `responderInst`.\r\n     *\r\n     * @param {NativeEvent} nativeEvent Native touch end event.\r\n     * @return {boolean} Whether or not this touch end event ends the responder.\r\n     */\n\n\n    function noResponderTouches(nativeEvent) {\n      var touches = nativeEvent.touches;\n\n      if (!touches || touches.length === 0) {\n        return true;\n      }\n\n      for (var i = 0; i < touches.length; i++) {\n        var activeTouch = touches[i];\n        var target = activeTouch.target;\n\n        if (target !== null && target !== undefined && target !== 0) {\n          // Is the original touch location inside of the current responder?\n          var targetInst = getInstanceFromNode$1(target);\n\n          if (isAncestor(responderInst, targetInst)) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }\n\n    var ResponderEventPlugin = {\n      /* For unit testing only */\n      _getResponder: function () {\n        return responderInst;\n      },\n      eventTypes: eventTypes,\n\n      /**\r\n       * We must be resilient to `targetInst` being `null` on `touchMove` or\r\n       * `touchEnd`. On certain platforms, this means that a native scroll has\r\n       * assumed control and the original touch targets are destroyed.\r\n       */\n      extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n        if (isStartish(topLevelType)) {\n          trackedTouchCount += 1;\n        } else if (isEndish(topLevelType)) {\n          if (trackedTouchCount >= 0) {\n            trackedTouchCount -= 1;\n          } else {\n            console.error('Ended a touch event which was not counted in `trackedTouchCount`.');\n            return null;\n          }\n        }\n\n        ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);\n        var extracted = canTriggerTransfer(topLevelType, targetInst, nativeEvent) ? setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) : null; // Responder may or may not have transferred on a new touch start/move.\n        // Regardless, whoever is the responder after any potential transfer, we\n        // direct all touch start/move/ends to them in the form of\n        // `onResponderMove/Start/End`. These will be called for *every* additional\n        // finger that move/start/end, dispatched directly to whoever is the\n        // current responder at that moment, until the responder is \"released\".\n        //\n        // These multiple individual change touch events are are always bookended\n        // by `onResponderGrant`, and one of\n        // (`onResponderRelease/onResponderTerminate`).\n\n        var isResponderTouchStart = responderInst && isStartish(topLevelType);\n        var isResponderTouchMove = responderInst && isMoveish(topLevelType);\n        var isResponderTouchEnd = responderInst && isEndish(topLevelType);\n        var incrementalTouch = isResponderTouchStart ? eventTypes.responderStart : isResponderTouchMove ? eventTypes.responderMove : isResponderTouchEnd ? eventTypes.responderEnd : null;\n\n        if (incrementalTouch) {\n          var gesture = ResponderSyntheticEvent.getPooled(incrementalTouch, responderInst, nativeEvent, nativeEventTarget);\n          gesture.touchHistory = ResponderTouchHistoryStore.touchHistory;\n          accumulateDirectDispatches(gesture);\n          extracted = accumulate(extracted, gesture);\n        }\n\n        var isResponderTerminate = responderInst && topLevelType === TOP_TOUCH_CANCEL;\n        var isResponderRelease = responderInst && !isResponderTerminate && isEndish(topLevelType) && noResponderTouches(nativeEvent);\n        var finalTouch = isResponderTerminate ? eventTypes.responderTerminate : isResponderRelease ? eventTypes.responderRelease : null;\n\n        if (finalTouch) {\n          var finalEvent = ResponderSyntheticEvent.getPooled(finalTouch, responderInst, nativeEvent, nativeEventTarget);\n          finalEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n          accumulateDirectDispatches(finalEvent);\n          extracted = accumulate(extracted, finalEvent);\n          changeResponder(null);\n        }\n\n        return extracted;\n      },\n      GlobalResponderHandler: null,\n      injection: {\n        /**\r\n         * @param {{onChange: (ReactID, ReactID) => void} GlobalResponderHandler\r\n         * Object that handles any change in responder. Use this to inject\r\n         * integration with an existing touch handling system etc.\r\n         */\n        injectGlobalResponderHandler: function (GlobalResponderHandler) {\n          ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;\n        }\n      }\n    }; // Inject react-dom's ComponentTree into this module.\n    // Keep in sync with ReactDOM.js, ReactTestUtils.js, and ReactTestUtilsAct.js:\n\n    var _ReactDOM$__SECRET_IN = ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Events;\n    var getInstanceFromNode = _ReactDOM$__SECRET_IN[0];\n    var getNodeFromInstance = _ReactDOM$__SECRET_IN[1];\n    var getFiberCurrentPropsFromNode = _ReactDOM$__SECRET_IN[2];\n    var injectEventPluginsByName = _ReactDOM$__SECRET_IN[3];\n    setComponentTree(getFiberCurrentPropsFromNode, getInstanceFromNode, getNodeFromInstance);\n    var ReactDOMUnstableNativeDependencies = Object.freeze({\n      ResponderEventPlugin: ResponderEventPlugin,\n      ResponderTouchHistoryStore: ResponderTouchHistoryStore,\n      injectEventPluginsByName: injectEventPluginsByName\n    });\n    var unstableNativeDependencies = ReactDOMUnstableNativeDependencies;\n    module.exports = unstableNativeDependencies;\n  })();\n}","map":null,"metadata":{},"sourceType":"script"}